<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>AnantKripa Meeting</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { --accent:#ff6600; --bg:#0f1724; --card:#0b1220; color-scheme: dark; }
  body { margin:0; font-family:Inter, system-ui, Arial; background:linear-gradient(180deg,#041022,#0f1724); color:#fff; height:100vh; overflow:hidden; }
  .topbar{position:fixed;left:0;right:0;top:0;height:56px;display:flex;align-items:center;gap:12px;padding:8px 16px;background:linear-gradient(90deg, rgba(0,0,0,0.45), transparent);z-index:40}
  .logo{font-weight:700;color:var(--accent)}
  #videos { position:absolute; inset:56px 260px 80px 0; display:grid; gap:8px; padding:12px; box-sizing:border-box; grid-auto-rows:1fr; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); }
  .video-card { position:relative; background:#000; border-radius:12px; overflow:hidden; display:flex; align-items:center; justify-content:center; }
  video { width:100%; height:100%; object-fit:cover; background:#000; }
  .badge { position:absolute; top:8px; left:8px; background:#0008; padding:6px 10px; border-radius:999px; font-size:13px; display:flex; gap:8px; align-items:center; }
  .host-badge { background: linear-gradient(90deg,#ffb86b,#ff6a00); color:#111; padding:6px 10px; border-radius:999px; font-weight:700; }
  #bottomBar { position:fixed; left:50%; transform:translateX(-50%); bottom:16px; background:#08101a80; padding:10px 14px; border-radius:40px; display:flex; gap:12px; z-index:50; align-items:center; }
  .btn { background:var(--accent); border:0; padding:10px 12px; border-radius:999px; cursor:pointer; color:#fff; font-weight:700; }
  .icon-btn { width:48px;height:48px;border-radius:24px;background:#111;display:flex;align-items:center;justify-content:center;cursor:pointer; color:#fff; font-size:18px; }
  #chat { position:fixed; right:12px; bottom:90px; width:320px; max-height:60vh; background:rgba(0,0,0,0.45); border-radius:12px; overflow:hidden; display:flex; flex-direction:column; z-index:60; }
  #chat .messages { padding:12px; overflow:auto; flex:1; font-size:14px; }
  #chat .input { display:flex; gap:8px; padding:8px; }
  #chat input{flex:1;padding:8px;border-radius:8px;border:0}
  #emojiPanel { position:fixed; left:12px; bottom:90px; display:flex; gap:8px; z-index:60; }
  /* floating emoji */
  .floating-emoji { position:fixed; pointer-events:none; z-index:9999; text-shadow:0 8px 20px rgba(0,0,0,0.35); }
  /* donate modal */
  .modal-bg { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.6); z-index:9999; }
  .modal { background:#fff; color:#111; padding:18px; border-radius:12px; width:320px; text-align:center; }
  /* participants sidebar */
  #participants { position:fixed; right:0; top:56px; width:260px; bottom:80px; background:rgba(5,8,15,0.85); border-left:1px solid rgba(255,255,255,0.03); padding:12px; overflow:auto; z-index:70; }
  #participants h3{ margin:0 0 8px 0; font-size:16px; color:#fff; }
  .participant { padding:8px 10px; border-radius:8px; display:flex; justify-content:space-between; gap:8px; align-items:center; margin-bottom:8px; background:rgba(255,255,255,0.02); }
  .waiting-box { position:fixed; left:50%; top:70px; transform:translateX(-50%); z-index:90; background:#0b1220; color:#fff; padding:12px; border-radius:10px; box-shadow:0 8px 20px rgba(0,0,0,0.5); display:none; }
  .small-btn { background:#222; border:0; color:#fff; padding:6px 8px; border-radius:6px; cursor:pointer; }
  /* ended overlay */
  #endedOverlay { position:fixed; inset:0; background:rgba(0,0,0,0.85); color:#fff; display:none; align-items:center; justify-content:center; z-index:99999; font-size:22px; text-align:center; padding:20px; }
</style>
</head>
<body>

<div class="topbar">
  <div class="logo">AnantKripa Meet</div>
  <div id="roomLabel"></div>
</div>

<div id="videos"></div>

<!-- Participants sidebar -->
<div id="participants">
  <h3>üë• Participants</h3>
  <div id="usersList"></div>
</div>

<div id="emojiPanel">
  <button class="icon-btn" title="Diya" onclick="localEmoji('ü™î')">ü™î</button>
  <button class="icon-btn" title="Flower" onclick="localEmoji('üå∏')">üå∏</button>
  <button class="icon-btn" title="Bell" onclick="localEmoji('üîî')">üîî</button>
</div>

<div id="chat">
  <div class="messages" id="messages"></div>
  <div class="input">
    <input id="chatInput" placeholder="Type message..." />
    <button id="sendChat" class="btn">Send</button>
  </div>
</div>

<div id="bottomBar">
  <div class="icon-btn" id="btnMic" onclick="toggleMic()">üé§</div>
  <div class="icon-btn" id="btnCam" onclick="toggleCam()">üì∑</div>
  <div class="icon-btn" id="btnShare" onclick="startScreen()">üñ•Ô∏è</div>
  <button class="btn" id="btnRecord" onclick="toggleRecord()">‚è∫Ô∏è</button>
  <button class="btn" onclick="openDonate()">Donate</button>
</div>

<!-- donate modal -->
<div class="modal-bg" id="donateModal">
  <div class="modal">
    <h3>Support AnantKripa</h3>
    <img src="assets/mobile.png" alt="QR" style="width:220px">
    <p style="margin-top:8px">Scan QR to donate</p>
    <div style="margin-top:12px">
      <button class="btn" onclick="closeDonate()">Close</button>
    </div>
  </div>
</div>

<!-- waiting box for host -->
<div class="waiting-box" id="waitingBox">
  <div id="waitingText">Users waiting: <span id="waitingCount">0</span></div>
  <div style="margin-top:8px;">
    <button class="small-btn" onclick="approveAll()">Approve All</button>
  </div>
</div>

<!-- ended overlay -->
<div id="endedOverlay">‚ùå The host has ended the meeting. Thank you.</div>

<!-- hidden file input for screenshot upload -->
<input type="file" id="ssFile" accept="image/*" style="display:none" />

<script src="/socket.io/socket.io.js"></script>
<script src="https://unpkg.com/simple-peer@9.11.1/simplepeer.min.js"></script>

<script>
/* ====== CONFIG & PARAMS ====== */
const urlParams = new URLSearchParams(window.location.search);
const ROOM = (urlParams.get('room') || 'room-default').replace(/\s+/g,'-');
const NAME = urlParams.get('name') || ('Guest' + Math.floor(Math.random()*999));
const IS_HOST = (urlParams.get('host') === '1' || urlParams.get('host') === 'true');
const SERVER = location.origin; // Render app origin
document.getElementById('roomLabel').textContent = 'Room: ' + ROOM;

const ICE_SERVERS = (function(){
  try { return JSON.parse(decodeURIComponent(urlParams.get('ice') || '')) } catch(e){ return (window.__ICE || []) }
})();

/* ====== SOCKET & STATE ====== */
const socket = io(SERVER, { transports: ['websocket','polling'] });

let localStream = null;
let peers = {};             // peerId -> SimplePeer
let peerVideoEls = {};      // peerId -> element
let peerNames = {};         // peerId -> {name, isHost}
let mediaRecorder = null;
let recordedChunks = [];

/* ====== UI helpers ====== */
function showEndedOverlay(){ document.getElementById('endedOverlay').style.display = 'flex'; }
function hideEndedOverlay(){ document.getElementById('endedOverlay').style.display = 'none'; }

/* ====== local media ====== */
async function initLocal() {
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
    addVideoEl('local', localStream, NAME + (IS_HOST ? ' (Host)' : ' (You)'), true, IS_HOST);
  } catch(err) {
    console.error('getUserMedia error', err);
    alert('Camera/mic access required to join.');
  }
}

/* ====== socket flow ====== */

// On connect, if host ‚Üí directly join room, else request approval
socket.on('connect', () => {
  console.log('connected', socket.id, 'host?', IS_HOST);
  if (IS_HOST) {
    socket.emit('join-room', { room: ROOM, userName: NAME, host: true });
    // request current users list (server may not provide; peer-joined events will come)
  } else {
    // ask to join (waiting room)
    socket.emit('join-request', { room: ROOM, userName: NAME });
  }
});

// When server returns peers list (could be array of ids OR array of objects with metadata)
socket.on('peers', async (others) => {
  // handle both shapes: ["id1","id2"] OR [{id,name,isHost}, ...]
  const ids = [];
  if (!Array.isArray(others)) return;
  for (const o of others) {
    if (typeof o === 'string') ids.push(o);
    else if (o && o.id) {
      ids.push(o.id);
      peerNames[o.id] = { name: o.userName || o.name || 'Participant', isHost: !!o.isHost };
    }
  }
  for (const id of ids) {
    await preparePeer(id, true);
  }
});

// server notifies when someone joined after you
socket.on('peer-joined', async ({ id, userName, isHost }) => {
  peerNames[id] = { name: userName || 'Participant', isHost: !!isHost };
  await preparePeer(id, false);
  updateUsersList();
});

// server sends signal messages
socket.on('signal', async ({ from, data }) => {
  if (peers[from]) {
    peers[from].signal(data);
  } else {
    // create peer if offer came
    await preparePeer(from, false, data);
  }
});

// peer left
socket.on('peer-left', ({ id }) => {
  removePeer(id);
  delete peerNames[id];
  updateUsersList();
});

// waiting room - host receives list
socket.on('waiting-user', (list) => {
  // list is array of {id,name}
  const box = document.getElementById('waitingBox');
  const cnt = (list && list.length) || 0;
  document.getElementById('waitingCount').textContent = cnt;
  if (IS_HOST && cnt > 0) {
    box.style.display = 'block';
  } else {
    box.style.display = 'none';
  }
});

// approved to join (guest)
socket.on('approved', (room) => {
  if (room === ROOM) {
    // now officially join the room
    socket.emit('join-room', { room: ROOM, userName: NAME });
  }
});

// meeting ended -> everyone
socket.on('meeting-ended', () => {
  // gracefully stop local media
  if (localStream) {
    localStream.getTracks().forEach(t => t.stop());
  }
  // show overlay and disconnect
  showEndedOverlay();
  setTimeout(() => {
    try { socket.disconnect(); } catch(e){ }
    // optionally redirect to homepage
    // window.location.href = 'https://anantkripa.in';
  }, 1500);
});

/* ====== prepare peer (simple-peer) ====== */
async function preparePeer(peerId, initiator=false, incomingSignal=null) {
  if (peers[peerId]) return;
  const iceConfig = ICE_SERVERS && ICE_SERVERS.length ? ICE_SERVERS : [{ urls: 'stun:stun.l.google.com:19302' }];
  const p = new SimplePeer({ initiator, trickle: true, stream: localStream, config: { iceServers: iceConfig } });
  peers[peerId] = p;

  // when this client generates signaling data
  p.on('signal', data => {
    socket.emit('signal', { to: peerId, data });
  });

  // remote stream received
  p.on('stream', stream => {
    const info = peerNames[peerId] || { name: 'Participant', isHost: false };
    addVideoEl(peerId, stream, info.name + (info.isHost ? ' (Host)' : ''), false, info.isHost);
    updateUsersList();
  });

  p.on('close', () => { removePeer(peerId); });
  p.on('error', e => { console.warn('peer error', e); removePeer(peerId); });

  if (incomingSignal) p.signal(incomingSignal);
}

/* ====== add / remove video elements ====== */
function addVideoEl(id, stream, label, muted=false, isHost=false) {
  // if element exists, update stream
  const existing = document.getElementById('card-' + id);
  if (existing) {
    const vid = existing.querySelector('video');
    if (vid) vid.srcObject = stream;
    const badge = existing.querySelector('.badge');
    if (badge) badge.innerHTML = getBadgeHtml(label, isHost);
    peerVideoEls[id] = existing;
    return;
  }

  const videos = document.getElementById('videos');
  const card = document.createElement('div');
  card.className = 'video-card';
  card.id = 'card-' + id;

  const vid = document.createElement('video');
  vid.autoplay = true;
  vid.playsinline = true;
  vid.muted = !!muted;
  vid.srcObject = stream;

  const badge = document.createElement('div');
  badge.className = 'badge';
  badge.innerHTML = getBadgeHtml(label, isHost);

  card.appendChild(vid);
  card.appendChild(badge);
  videos.appendChild(card);
  peerVideoEls[id] = card;
}

function getBadgeHtml(label, isHost) {
  if (isHost) {
    return `<span class="host-badge">Host</span> <span style="margin-left:8px">${escapeHtml(label)}</span>`;
  }
  return `<span>${escapeHtml(label)}</span>`;
}

function removePeer(id) {
  const el = document.getElementById('card-' + id);
  if (el) el.remove();
  if (peers[id]) { try { peers[id].destroy(); } catch(e){} delete peers[id]; }
  delete peerVideoEls[id];
}

/* ====== Chat ====== */
document.getElementById('sendChat').addEventListener('click', () => {
  const v = document.getElementById('chatInput').value.trim();
  if (!v) return;
  socket.emit('send-chat', { room: ROOM, message: v });
  appendChat(NAME, v);
  document.getElementById('chatInput').value = '';
});
function appendChat(name, msg) {
  const wrap = document.getElementById('messages');
  const el = document.createElement('div');
  el.style.marginBottom = '8px';
  el.innerHTML = `<b>${escapeHtml(name)}:</b> ${escapeHtml(msg)}`;
  wrap.appendChild(el);
  wrap.scrollTop = wrap.scrollHeight;
}

/* ====== emoji ====== */
function localEmoji(emoji) {
  showFloatingEmoji(emoji);
  socket.emit('emoji', { room: ROOM, emoji });
}
function showFloatingEmoji(emoji) {
  const el = document.createElement('div');
  el.className = 'floating-emoji';
  el.textContent = emoji;
  const left = (Math.random()*60 + 20) + '%';
  Object.assign(el.style, {
    left,
    bottom: '110px',
    fontSize: '72px',
    opacity: '0.75',
    transform: 'translateY(0)',
    transition: 'transform 1.8s ease-out, opacity 1.8s ease-out'
  });
  document.body.appendChild(el);
  requestAnimationFrame(() => {
    el.style.transform = 'translateY(-260px)';
    el.style.opacity = '0';
  });
  setTimeout(()=>el.remove(), 1900);
}

/* ====== controls: mic/cam/screenshare ====== */
function toggleMic(){
  if(!localStream) return;
  const audioTrack = localStream.getAudioTracks()[0];
  if(!audioTrack) return;
  audioTrack.enabled = !audioTrack.enabled;
  document.getElementById('btnMic').textContent = audioTrack.enabled ? 'üé§' : 'üîá';
}
function toggleCam(){
  if(!localStream) return;
  const videoTrack = localStream.getVideoTracks()[0];
  if(!videoTrack) return;
  videoTrack.enabled = !videoTrack.enabled;
  document.getElementById('btnCam').textContent = videoTrack.enabled ? 'üì∑' : 'üö´';
}
async function startScreen(){
  try {
    const s = await navigator.mediaDevices.getDisplayMedia({video:true});
    const screenTrack = s.getVideoTracks()[0];
    for(const id in peers) {
      const p = peers[id];
      const sender = p._pc && p._pc.getSenders().find(s => s.track && s.track.kind === 'video');
      if (sender) sender.replaceTrack(screenTrack);
    }
    addVideoEl('screen-local', s, NAME + ' (screen)', true, false);
    screenTrack.onended = () => {
      const camTrack = localStream.getVideoTracks()[0];
      for(const id in peers) {
        const p = peers[id];
        const sender = p._pc && p._pc.getSenders().find(s => s.track && s.track.kind === 'video');
        if (sender && camTrack) sender.replaceTrack(camTrack);
      }
      const el = document.getElementById('card-screen-local');
      if (el) el.remove();
    };
  } catch(e) {
    console.warn('screen share denied', e);
  }
}

/* ====== local recording ====== */
function toggleRecord(){
  if (!mediaRecorder || mediaRecorder.state === 'inactive') startRecording();
  else stopRecording();
}
function startRecording(){
  if (!localStream) return alert('No local stream');
  const combined = new MediaStream();
  localStream.getTracks().forEach(t => combined.addTrack(t));
  mediaRecorder = new MediaRecorder(combined, { mimeType: 'video/webm; codecs=vp8' });
  recordedChunks = [];
  mediaRecorder.ondataavailable = e => { if (e.data.size) recordedChunks.push(e.data); };
  mediaRecorder.onstop = () => {
    const blob = new Blob(recordedChunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `${ROOM}_${Date.now()}.webm`; a.click();
    URL.revokeObjectURL(url);
  };
  mediaRecorder.start();
  document.getElementById('btnRecord').textContent = '‚èπÔ∏è';
}
function stopRecording(){
  if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
  document.getElementById('btnRecord').textContent = '‚è∫Ô∏è';
}

/* ====== screenshot upload ====== */
document.getElementById('ssFile').addEventListener('change', (e) => {
  const f = e.target.files[0];
  if (!f) return;
  uploadScreenshotFile(f);
});
async function uploadScreenshotFile(file) {
  const fd = new FormData();
  fd.append('screenshot', file);
  fd.append('room', ROOM);
  const res = await fetch('https://anantkripa.in/upload_screenshot.php', {
    method: 'POST', body: fd, credentials: 'include'
  });
  const j = await res.json();
  if (j.success) alert('Uploaded');
  else alert('Upload failed');
}

/* ====== waiting room actions (host) ====== */
function approveAll(){
  socket.emit('approve-all', ROOM);
  document.getElementById('waitingBox').style.display = 'none';
}

/* ====== participant list update ====== */
function updateUsersList(){
  const wrap = document.getElementById('usersList');
  wrap.innerHTML = '';
  // local first
  const localHtml = `<div class="participant"><div><b>${escapeHtml(NAME)}</b> <div style="font-size:12px;color:#bbb">You${IS_HOST? ' ‚Ä¢ Host':''}</div></div><div></div></div>`;
  wrap.insertAdjacentHTML('beforeend', localHtml);
  // other peers
  for (const id in peerNames) {
    const info = peerNames[id] || { name: id, isHost:false };
    const label = escapeHtml(info.name) + (info.isHost ? ' (Host)' : '');
    wrap.insertAdjacentHTML('beforeend', `<div class="participant"><div>${label}</div><div></div></div>`);
  }
}

/* ====== helpers ====== */
function escapeHtml(s){ if(!s) return ''; return String(s).replace(/[&<>"']/g, c=>'&#'+c.charCodeAt(0)+';'); }

/* ====== start everything ====== */
(async function(){
  window.__ICE = window.__ICE || (typeof __ICE !== 'undefined' ? __ICE : []);
  await initLocal();
  // If guest, show a small notice while waiting (optional)
  if (!IS_HOST) {
    const notice = document.createElement('div');
    notice.style.position='fixed';
    notice.style.left='50%'; notice.style.top='64px';
    notice.style.transform='translateX(-50%)';
    notice.style.background='#111'; notice.style.color='#fff';
    notice.style.padding='8px 12px'; notice.style.borderRadius='8px';
    notice.style.zIndex=90;
    notice.id='waitingNotice';
    notice.textContent = 'Waiting for host approval...';
    document.body.appendChild(notice);
  }

  // update users list periodically (some peers names arrive later)
  setInterval(updateUsersList, 1200);
})();
</script>
</body>
</html>
